html
    head
        title Eye Cloud
        script(src="https://d3js.org/d3.v5.min.js")
    body
        div.graph
        script(type="text/javascript").
            const width = window.innerWidth; // Width of the web page inside the browser
            const height = window.innerHeight; // Height of the web page inside the browser

            const map = 0;

            const range = 150;

            // Create an svg- and g-tag inside the graph class
            let svg = d3.select('.graph')
                .append('svg')
                .attr('width', '100%') // Full screen
                .attr('height', '100%') // Full screen
                .append('g')
                .attr('transform', 'translate(0,0)')

            // Create a defs-tag inside the svg-tag
            d3.select('svg')
                .append('defs')

            // We must load the dataset as a tsv, since its values are separated by tabs, not commas
            d3.tsv('/testdataset/all_fixation_data_cleaned_up.csv').then( function (data) {
                // TODO: Data handling:
                    //  Merge the coordinates
                    //  Store density of the coordinates

                let dataByCity = d3.nest().key(function (data) { // Nest the data by StimuliName
                    return data.StimuliName;
                }).entries(data);

                let mapObject = {}; // Object that contains the images of the maps
                for (var i = 0; i < dataByCity.length; i++) {
                    mapObject[i] = Object.values(dataByCity)[i]['key'];
                }

                console.log('Selected map: ' + mapObject[map]);

                let coordinates = []; // Array of all the coordinates for the selected map
                // Generate the coordinate objects
                dataByCity[map]['values'].forEach(function (element) {
                    let x_coordinate = parseInt(element.MappedFixationPointX);
                    let y_coordinate = parseInt(element.MappedFixationPointY);
                    // Coordinates require the co_x and co_y tags in stead of just x and y to prevent issues with the
                    // x and y locations of the circles of the graph
                    coordinates.push({co_x: x_coordinate, co_y: y_coordinate});
                });

                console.log(coordinates);

                // Generate new coordinates where close coordinates are removed
                let newCoordinates = [];
                let densities = []; // the density of each coordinate in newCoordinates
                for (let i = 0; i < coordinates.length - 1; i++) {
                    let density = 0;
                    for (let j = i + 1; j < coordinates.length; j++) {
                        let xDistance = Math.pow(coordinates[j].co_x - coordinates[i].co_x, 2);
                        let yDistance = Math.pow(coordinates[j].co_y - coordinates[i].co_y, 2);
                        let distance = Math.sqrt(xDistance + yDistance);
                        if (distance <= range) { // If coordinate at j is inside of the radius of coordinate at i
                            coordinates.splice(j, 1); // Remove coordinate at j from coordinates array
                            density++;
                            j--; // Reset the index after deletion for the next iteration
                        }
                    }
                    newCoordinates.push(coordinates[i]);
                    densities.push(density);
                }

                console.log(newCoordinates);
                console.log(densities);

                // For each (new) coordinate object, create a pattern that contains the coordinates
                for (let i = 0; i < newCoordinates.length; i++) {
                    d3.select('defs')
                        .append('pattern')
                        .attr('id', 'map_c' + i) // Create id with the index of each object in the data
                        .attr('width', 1)
                        .attr('height', 1)
                        .append('image')
                        .attr('x', -newCoordinates[i].co_x + 'px') // Image coordinates have to be negated
                        .attr('y', -newCoordinates[i].co_y + 'px')
                        .attr('xlink:href', '/testdataset/images/' + mapObject[map]);
                }

                let densityMax = Math.max.apply(Math, densities);
                let densityMin = Math.min.apply(Math, densities);
                let radiusScale = d3.scaleSqrt().domain([densityMin, densityMax]).range([25, 125]);

                // Collection of forces that dictate where the circles should go
                // and how we want them to interact
                let collisionCount = -1; // Keeps track of the index of the densities array
                let simulation = d3.forceSimulation()
                    .force('x', d3.forceX(width / 2).strength(0.05))
                    .force('y', d3.forceY(height / 2).strength(0.075))
                    .force('collide', d3.forceCollide(function () {
                        collisionCount++;
                        return radiusScale(densities[collisionCount]) + 2
                        //return 25
                    }))

                let radiusCount = -1; // Keeps track of the index of the densities array
                let mapCount = -1; // Local variable that counts the number of maps of the circles
                let circles = svg.selectAll('.artist')
                    .data(newCoordinates)
                    .enter().append('circle')
                    //.attr('class', 'artist')
                    .attr('cx', width / 2)
                    .attr('cy', height / 2)
                    .attr('r', function () {
                        radiusCount++;
                        return radiusScale(densities[radiusCount])
                        //return 25
                    })
                    .attr('stroke', 'black')
                    .attr('fill', function () {
                        mapCount++
                        return 'url(#map_c' + mapCount + ')'
                    })

                // On every tick during the simulation, call the update function
                simulation.nodes(newCoordinates)
                    .on('tick', update)

                // Automatically update the location of each circle
                function update() {
                    circles
                        .attr('cx', function (d) {
                            return d.x
                        })
                        .attr('cy', function (d) {
                            return d.y
                        })
                }
            });
